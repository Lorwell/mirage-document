## 介绍

请求拦截器，在请求到达控制器之前处理，可以通过实现`HandlerInterceptor` 的方式来定义一个请求拦截器。

`HandlerInterceptor`提供了两个方法，分别是：

* preHandle
  在请求到达控制器前处理，使用此方法，每个拦截器都可以决定是否中止执行链，一般来说中止通常是发送HTTP错误或编写自定义响应。
* afterCompletion
  在响应数据写入后调用，一般来说用于请求结束后的资源清理或者日志等操作

另外也提供了`kotlin`的协程接口 `CoroutineHandlerInterceptor`以方便拓展使用

一般来说我们建议使用`@WebInterceptor`注解的方式去定义拦截器，另外我们也提供了`MirageWebMvcConfigurer`配置器的方式进行注册。

**java**

```java
@Component
@WebInterceptor
public class RequestInterceptor implements HandlerInterceptor {
    
    @Override
    public Future<Boolean> preHandle(HttpRequest request, HttpResponse response, VertxInvokeHandler handler) {
        // TODO...
        return Future.succeededFuture(true);
    }
    
    @Override
    public Future<Void> afterCompletion(HttpRequest request, HttpResponse response, VertxInvokeHandler handler, @Nullable Throwable cause) {
        // TODO...
        return Future.succeededFuture();
    }
}
```
**kotlin**

```kotlin
@Component
@WebInterceptor
open class RequestInterceptor : CoroutineHandlerInterceptor {
    
    override suspend fun doPreHandle(
        request: HttpRequest,
        response: HttpResponse,
        handler: VertxInvokeHandler
    ): Boolean {
        // TODO...
        return ture
    }

    override suspend fun doAfterCompletion(
        request: HttpRequest,
        response: HttpResponse,
        handler: VertxInvokeHandler,
        cause: Throwable?
    ) {
       // TODO...
    }
    
}
```

**使用 MirageWebMvcConfigurer 注册**

**java**

```java
@Configuration
public class WebMvcConfigurer implements MirageWebMvcConfigurer{
   
    @Override
    public void registerHandlerInterceptor(List<InterceptorMappingInfo> interceptorMappings) {
          // TODO...
    }
    
}
```

**kotlin**

```kotlin
@Configuration
open class WebMvcConfigurer : MirageWebMvcConfigurer{
   
    @Override
    fun registerHandlerInterceptor(interceptorMappings : List<InterceptorMappingInfo>) {
          // TODO...
    }
    
}
```

## 拦截请求映射

你可以使用`@WebInterceptor`注释来映射请求拦截，它拥有以下属性：

* includePatterns
  拦截路径模式，表示那些请求路径会被拦截
* excludePatterns
  排除路径模式，表示那些请求会被排除，该值应用与`includePatterns`匹配成功的路径

使用 `AntPathMatcher`来实现，使用以下规则匹配路径： 

* `?` 匹配一个字符
* `*`  匹配零个或多个字符
* `**` 匹配路径中的零个或多个目录

一些示例：

* `@WebInterceptor(includePatterns="/api/*")` 匹配所有以`/api`开头，但只有2层级的路径
* `@WebInterceptor(includePatterns="/api/**")` 匹配所有以`/api`开头，不限制层级的路径
* `@WebInterceptor(includePatterns="/api/t?st")` 匹配`/api/test`也匹配`/api/tast`
* `@WebInterceptor(includePatterns="/api/*",excludePatterns="/api/test")` 匹配所有以`/api`开头，但只有2层级的路径，排除`/api/test`

> 需要注意的是，当请求映射模式为`PATH`时，拦截器的匹配是在启动时，匹配控制器的映射路径并且将拦截器信息挂载在控制器处理调用链上，见`HandlerExecutionChain`。
>
> 存在以下假设逻辑：
>
> 一个拦截器规则为：`@WebInterceptor(includePatterns="/api/t?st")` ，
>
> 一个控制器映射为：`@RequestMapping(”/api/:value“)`
>
> 那么当一个请求信息`/api/test`映射到该控制器时，并不会被拦截器所拦截。
>
> 相对的，当请求映射模式为`REGEX`时，拦截器匹配是在收到请求时根据请求信息实时匹配的，这样的好处是拦截器映射更加准确，但是对应高性能来说是一场灾难。

