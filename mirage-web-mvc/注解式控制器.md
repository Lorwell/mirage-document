## 介绍

Mirage Web MVC 提供了一个基于注解的编程模型，使用`@Controller`或`@RestController`注解来表达请求映射、请求输入等组件。带注释的控制器具有灵活的方法签名，不必扩展基类，也不必实现特定的接口。以下示例显示了由注释定义的控制器：

**java**

```java
@RestController
public class HelloWordController {

    @GetMapping("/hello-word")
    public Future<Object> handle() {
        Map<String,String> result = new HashMap<>(2);
        result.put("code","ok");
        result.put("message","hello-word");
        return Future.successFuture(result);
    }
    
}
```

**kotlin**

```kotlin
@RestController
class HelloWordController {
    
   @GetMapping("/hello-word")
   suspend fun handle(): Any {
        val result: Map<String, String> = mutableMapOf()
        result.put("code", "ok")
        result.put("message", "hello-word")
        return result
    }
    
}
```

> `@RestController`是一个[组合注释](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-meta-annotations)，它本身是元注释的，它本身用`@Controller`和`@ResponseBody`进行元注释，以指示控制器的每个方法都继承了类型级别的`@ResponseBody`注释，因此，它直接写入响应主体。

### 请求映射

你可以使用`@RequestMapping`注释将请求映射到控制器方法，它具有以下属性，可以通过URL、HTTP方法、请求参数、报头和媒体类型进行匹配。你可以在类级别使用它来表示共享映射，或者在方法级别使用它来缩小到特定地址的映射

还有一些特定于HTTP方法的`@RequestMapping`的快捷方式的变体:

- @GetMapping
- @PostMapping
- @PutMapping
- @DeleteMapping
- @PatchMapping

提供的快捷方式是自定义注释，这是因为大多数控制器方法应该映射到特定的HTTP方法，而不是使用`@RequestMapping`，`@RequestMapping`在默认情况下匹配所有HTTP方法，所以在类级别仍然需要`@RequestMapping`来表示共享映射。

下面的例子有类型级和方法级的映射:

**java**

```java
@RestController
@RequestMapping("/api/user")
class UserController {

    @GetMapping("/:id")
    public Future<User> getUser(@PathVariable Long id) {
        // ...
    }

    @PostMapping
    public Future<User> add(@RequestBody User user) {
        // ...
    }
}
```

**kotlin**

```kotlin
@RestController
@RequestMapping("/api/user")
class UserController {

    @GetMapping("/:id")
    suspend fun getUser(@PathVariable id: Long): User {
        // ...
    }

    @PostMapping
    suspend fun add(@RequestBody user: User): User {
        // ...
    }
}
```

#### URI 模式

`@RequestMapping`可以使用 URL 模式映射方法，有三种选择：

* 基于精确路径的路由
  将映射模式设置为`PATH`，在这种情况下它只会匹配路径一致的请求，例如：`/api/user`
* 基于路径前缀的路由
  将映射模式设置为`PATH`，方式是在声明路径时使用一个 `*` 作为结尾，例如：`/api/user/*`
* 基于正则表达式的路由
  将映射模式设置为`REGEX`，即可使用正则表达式匹配路由的 URI 路径

一些示例：

- `/api/user`- 匹配精确路径
- `/api/user/*`- 匹配指定前缀的路径
- `"/api/user/:id"`- 匹配精确路径并将其捕获为变量
- `"\\/([^\\/]+)\\/([^\\/]+)"`- 正则匹配路径并将其捕获为变量
  例如：请求路径`/api/user` 路径匹配，`api` 可以通过参数 param0 获取，`user` 可以通过参数 param1 获取
- `\\/(?<p0>[^\\/]+)\\/(?<p1>[^\\/]+)`- 正则匹配路径并使用命名捕捉组的方式将其捕获为变量
  例如：请求路径`/api/user` 路径匹配，`api` 可以通过参数 p0 获取，`user` 可以通过参数 p1 获取

捕获的 URI 变量可以使用`@PathVariable`

#### 媒体类型 ContentType

你可以根据请求的`Content-Type`来缩小请求映射，示例如下:

**java**

```jade
@PostMapping(path = "/api/user", consumes = "application/json") 
public Future<User> addPet(@RequestBody User user) {
    // ...
}
```

**kotlin**

```kotlin
@PostMapping("/api/user", consumes = ["application/json"]) 
suspend fun addPet(@RequestBody user: User): User {
    // ...
}
```

可以在类级别声明共享的`consumes`属性，当在方法级别重写时会覆盖类级别声明

#### 媒体类型 Accept

你可以根据请求的`Accept`来缩小请求映射，如下所示:

**java**

```java
@GetMapping(path = "/api/user/:id", produces = "application/json") 
@ResponseBody
public Future<User> findUser(@PathVariable String id) {
    // ...
}
```

**kotlin**

```kotlin
@GetMapping("/api/user/:id", produces = ["application/json"]) 
@ResponseBody
suspend fun findUser(@PathVariable id: String): User {
    // ...
}
```

可以在类级别声明共享的`produces`属性，当在方法级别重写时会覆盖类级别声明

#### 方法参数

下表描述了支持的控制器方法参数

| 方法参数       | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| RoutingContext | 当前的路由上下文对象                                         |
| HttpRequest    | 当前的请求对象                                               |
| HttpResponse   | 当前的响应对象                                               |
| @FileUpload    | 文件上传注解，指方法参数的注解应该绑定到web请求的文件上，与 `MultipartFileUpload` 组合使用，用于处理文件上传请求 |
| @FormAttribute | Form 表单参数注解，指方法参数应绑定到HTTP表单的属性上        |
| @PathVariable  | 路径参数注解，指方法参数应绑定到HTTP路径变量上，例如： 当前方法的路径绑定`RequestMapping("/api/user/:id")`，请求路径为`/api/user/1`， 那么指定的路径变量`id`的值为  `1` |
| @QueryParam    | 查询参数注解，指方法参数应绑定到HTTP查询参数上，例如：`/api/user?x1=xx&x2=x2` 中的 `x1=xx&x2=x2` |
| @RequestBody   | 请求主体参数注解，指方法参数的注解应该绑定到web请求的主体，请求的主体通过`HttpMessageConverter`来解析方法参数，具体取决于请求的内容类型。 |
| @RequestHeader | 请求头参数注解，指方法参数应绑定到HTTP请求头上               |

#### 返回值

下表描述了支持的控制器方法返回值

| 返回值        | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| Future        | 所有注解方法的返回值都应该有`Future`对象包裹[kotlin的协程方法除外](Kotlin 协程.md)，以下返回值表示的都是 `Future` 所包裹的类型。 |
| Buffer        | Vertx 内核所使用的缓冲区对象，可以直接作为方法的返回值结果，其结果将不进行任何解析处理，直接写入响应主体。 |
| @ResponseBody | 响应注解方法注解，指方法返回值应绑定到web响应体上。支持带定义在类级别，方法级别未定义则继承类级别。响应的主体通过`HttpMessageConverter`来解析方法返回值，具体取决于响应的内容类型，它仅允许渲染对象的结果值。 |

#### Jackson JSON

mirage 提供对 Jackson JSON库的支持，要将其与 `@ResponseBody`标识的控制器方法一起使用，它仅允许渲染对象的结果值。

### 控制器增强

`@ControllerAdvice`用于增强`@Controller`控制器的功能，你可以使用它来声明异常处理器`@ExceptionHandler`，以及后续的相关拓展...

> `@RestControllerAdvice`是一个[组合注释](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-meta-annotations)，它本身是元注释的，它本身用`@ControllerAdvice`和`@ResponseBody`进行元注释，以指示控制器增强的每个方法都继承了类型级别的`@ResponseBody`注释，因此，它直接写入响应主体。

* [`@ExceptionHandler`](异常处理器.md#ExceptionHandlerExceptionResolver)

