## 介绍

Mirage Web Mvc 提供了一个基于注解的编程模型，使用`@Controller`和`@RestController`注解来表达请求映射、请求输入等组件。带注释的控制器具有灵活的方法签名，不必扩展基类，也不必实现特定的接口。以下示例显示了由注释定义的控制器：

**java**

```java
@RestController
public class HelloWordController {

    @GetMapping("/hello-word")
    public Future<Object> handle() {
        Map<String,String> result = new HashMap<>(2);
        result.put("code","ok");
        result.put("message","hello-word");
        return result;
    }
    
}
```

**kotlin**

```kotlin
@RestController
class HelloWordController {
    
   @GetMapping("/hello-word")
   suspend fun handle(): Any {
        val result: Map<String, String> = mutableMapOf()
        result.put("code", "ok")
        result.put("message", "hello-word")
        return result
    }
    
}
```

> `@RestController`是一个[组合注释](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-meta-annotations)，它本身是元注释的，它本身用`@Controller`和`@ResponseBody`进行元注释，以指示控制器的每个方法都继承了类型级别的`@ResponseBody`注释，因此，它直接写入响应主体。

### 请求映射

你可以使用`@RequestMapping`注释将请求映射到控制器方法，它具有以下属性，可以通过URL、HTTP方法、请求参数、报头和媒体类型进行匹配。您可以在类级别使用它来表示共享映射，或者在方法级别使用它来缩小到特定地址的映射

还有一些特定于HTTP方法的`@RequestMapping`的快捷方式的变体:

- @GetMapping
- @PostMapping
- @PutMapping
- @DeleteMapping
- @PatchMapping

提供的快捷方式是自定义注释，这是因为大多数控制器方法应该映射到特定的HTTP方法，而不是使用`@RequestMapping`。`@RequestMapping`在默认情况下匹配所有HTTP方法，所以在类级别仍然需要`@RequestMapping`来表示共享映射。

下面的例子有类型级和方法级的映射:

**java**

```java
@RestController
@RequestMapping("/api/user")
class UserController {

    @GetMapping("/:id")
    public Future<User> getUser(@PathVariable Long id) {
        // ...
    }

    @PostMapping
    public Future<User> add(@RequestBody User user) {
        // ...
    }
}
```

**kotlin**

```kotlin
@RestController
@RequestMapping("/api/user")
class UserController {

    @GetMapping("/:id")
    suspend fun getUser(@PathVariable id: Long): User {
        // ...
    }

    @PostMapping
    suspend fun add(@RequestBody user: User): User {
        // ...
    }
}
```

#### URI 模式

`@RequestMapping`可以使用 URL 模式映射方法，有三种选择：

* 基于精确路径的路由
  将映射模式设置为`PATH`，在这种情况下它只会匹配路径一致的请求，例如：`/api/user`
* 基于路径前缀的路由
  将映射模式设置为`PATH`，方式是在声明路径时使用一个 `*` 作为结尾，例如：`/api/user/*`
* 基于正则表达式的路由
  将映射模式设置为`REGEX`，即可使用正则表达式匹配路由的 URI 路径

一些示例：

- `/api/user`- 匹配精确路径
- `/api/user/*`- 匹配指定前缀的路径
- `"/api/user/:id"`- 匹配精确路径并将其捕获为变量
- `"\\/([^\\/]+)\\/([^\\/]+)"`- 正则匹配路径并将其捕获为变量
  例如：请求路径`/api/user` 路径匹配，`api` 可以通过参数 param0 获取，`user` 可以通过参数 param1 获取
- `\\/(?<p0>[^\\/]+)\\/(?<p1>[^\\/]+)`- 正则匹配路径并使用命名捕捉组的方式将其捕获为变量
  例如：请求路径`/api/user` 路径匹配，`api` 可以通过参数 p0 获取，`user` 可以通过参数 p1 获取

捕获的 URI 变量可以使用`@PathVariable`

#### Consumable Media Types

您可以根据请求的`Content-Type`来缩小请求映射，示例如下:

**java**

```jade
@PostMapping(path = "/api/user", consumes = "application/json") 
public Future<User> addPet(@RequestBody User user) {
    // ...
}
```

**kotlin**

```kotlin
@PostMapping("/api/user", consumes = ["application/json"]) 
suspend fun addPet(@RequestBody user: User): User {
    // ...
}
```

可以在类级别声明共享的`consumes`属性，当在方法级别重写时会覆盖类级别声明

#### Producible Media Types

您可以根据Accept请求头和控制器方法生成的内容类型列表来缩小请求映射，如下所示:

**java**

```java
@GetMapping(path = "/api/user/:id", produces = "application/json") 
@ResponseBody
public Future<User> findUser(@PathVariable String id) {
    // ...
}
```

**kotlin**

```kotlin
@GetMapping("/api/user/:id", produces = ["application/json"]) 
@ResponseBody
suspend fun findUser(@PathVariable id: String): User {
    // ...
}
```

可以在类级别声明共享的`produces`属性，当在方法级别重写时会覆盖类级别声明





